using System;
using System.Collections.Generic;
using System.Data.SQLite;
using System.IO;
using System.Linq;
using System.Text;
using static xivModdingFramework.Cache.XivCache;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using xivModdingFramework.General.Enums;
using xivModdingFramework.Helpers;
using xivModdingFramework.Items.Categories;
using xivModdingFramework.Items.DataContainers;
using xivModdingFramework.Items.Enums;
using xivModdingFramework.Items.Interfaces;
using xivModdingFramework.Materials.FileTypes;
using xivModdingFramework.Models.FileTypes;
using xivModdingFramework.Mods.DataContainers;
using xivModdingFramework.Mods.FileTypes;
using xivModdingFramework.Mods;
using xivModdingFramework.SqPack.DataContainers;
using xivModdingFramework.SqPack.FileTypes;
using xivModdingFramework.Textures.FileTypes;
using xivModdingFramework.Variants.FileTypes;
using System.Security.Policy;
using System.Security.Cryptography;

namespace xivModdingFramework.Cache
{

    // A naive representation of a dependency root/root folder in FFXIV's
    // File System.  Provides basic calculated fields, however, more extensive
    // calculations expect this item to be fully qualified and properly contained
    // in an actual dependency root object, accessible via .ToRoot()
    public struct XivDependencyRootInfo : ICloneable
    {
        // Only types with actual dependency structures are supported.
        // This means Equipment, Accessory, Monster, and Demihuman.
        public XivItemType PrimaryType;


        // All roots have at least a primary set Id.
        public int PrimaryId;

        /// <summary>
        /// Secondary types are optional.  Human Equipment in particular has no secondary type; they're just
        /// set as Equipment primary.
        /// </summary>
        public XivItemType? SecondaryType;

        // Secondary Id may not exist for all types.
        public int? SecondaryId;

        // In Abbreviated internal format -NOT- local language format.
        // Slot may not exist for all types.
        public string? Slot;

        public XivDependencyRootInfo GetOtherSlot(string slot)
        {
            return new XivDependencyRootInfo()
            {
                PrimaryId = PrimaryId,
                PrimaryType = PrimaryType,
                SecondaryId = SecondaryId,
                SecondaryType = SecondaryType,
                Slot = slot
            };
        }

        /// <summary>
        /// Converts this dependency root into a raw string entry.
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return GetRootFile();
        }
        public object Clone()
        {
            return this.MemberwiseClone();
        }

        public bool IsValid()
        {
            if (PrimaryType == XivItemType.unknown || PrimaryType == XivItemType.none)
            {
                return false;
            }
            if (PrimaryType == XivItemType.human && PrimaryId == 0)
            {
                // Bad root generated by some of the less well behaved Character "Items".
                return false;
            }

            return true;
        }

        // Type -> Typecode -> Id
        private static readonly string RootFolderFormatPrimary = "chara/{0}/{1}{2}/";

        // Type -> TypeCode -> Id
        private static readonly string RootFolderFormatSecondary = "obj/{0}/{1}{2}/";

        private static readonly string HousingRootFolderFormat = "bgcommon/hou/{0}/general/{1}/";
        private static readonly string FishPaintingRootFolderFormat = "bgcommon/hou/indoor/{0}/{1}/{2}/";


        // pPrefix => pId => sPrefix => sId => Slot
        private static readonly string BaseFileFormatWithSlot = "{0}{1}{2}{3}_{4}";
        private static readonly string BaseFileFormatNoSlot = "{0}{1}{2}{3}";

        // {0} = BaseFileFormat
        private static readonly string ModelNameFormat = "{0}.mdl";

        /// <summary>
        /// Gets the file name base for this root.
        /// Ex c0101f0001_fac
        /// </summary>
        /// <returns></returns>
        public string GetBaseFileName(bool includeSlot = true)
        {
            var pId = PrimaryId.ToString().PadLeft(4, '0');
            var pPrefix = XivItemTypes.GetSystemPrefix(PrimaryType);
            var sId = "";
            var sPrefix = "";
            if (SecondaryType != null)
            {
                sId = SecondaryId.ToString().PadLeft(4, '0');
                sPrefix = XivItemTypes.GetSystemPrefix((XivItemType)SecondaryType);
            }

            if (Slot != null && includeSlot)
            {
                return String.Format(BaseFileFormatWithSlot, new string[] { pPrefix, pId, sPrefix, sId, Slot });
            }
            else
            {
                return String.Format(BaseFileFormatNoSlot, new string[] { pPrefix, pId, sPrefix, sId });
            }
        }

        public string GetRootFile()
        {
            return GetRootFolder() + GetBaseFileName() + ".meta";
        }

        /// <summary>
        /// Gets the root folder for this depenedency root.
        /// </summary>
        /// <returns></returns>
        public string GetRootFolder()
        {
            if (PrimaryType == XivItemType.indoor || PrimaryType == XivItemType.outdoor)
            {
                // BGCommon Dat stuff.
                var pId = PrimaryId.ToString().PadLeft(4, '0');
                return String.Format(HousingRootFolderFormat, new string[] { XivItemTypes.GetSystemName(PrimaryType), pId });
            }
            else if (PrimaryType == XivItemType.fish || PrimaryType == XivItemType.painting)
            {
                var folder = "ta";
                if (PrimaryType == XivItemType.fish)
                {
                    folder = XivFish.IntSizeToString(SecondaryId.Value);
                }

                var pId = PrimaryId.ToString().PadLeft(4, '0');
                return String.Format(FishPaintingRootFolderFormat, new string[] { XivItemTypes.GetSystemName(PrimaryType), folder, pId });
            }
            else
            {
                // All the Dat 4 stuff.
                var pId = PrimaryId.ToString().PadLeft(4, '0');
                var primary = String.Format(RootFolderFormatPrimary, new string[] { XivItemTypes.GetSystemName(PrimaryType), XivItemTypes.GetSystemPrefix(PrimaryType), pId });

                var secondary = "";
                if (SecondaryType != null)
                {
                    var sId = SecondaryId.ToString().PadLeft(4, '0');
                    var sType = (XivItemType)SecondaryType;
                    secondary = String.Format(RootFolderFormatSecondary, new string[] { XivItemTypes.GetSystemName(sType), XivItemTypes.GetSystemPrefix(sType), sId });
                }

                return primary + secondary;
            }
        }


        public bool UsesMaterialSets()
        {
            if (Imc.UsesImc(this))
            {
                return true;
            }
            if(PrimaryType == XivItemType.human)
            {
                // Human folder is always an adventure.
                if(SecondaryType == XivItemType.ear
                    || SecondaryType == XivItemType.face)
                {
                    return false;
                }
                return true;
            }
            return false;

        }


        public string GetModelPath(XivRace race = XivRace.All_Races)
        {
            if(PrimaryType == XivItemType.fish 
                || PrimaryType == XivItemType.indoor
                || PrimaryType == XivItemType.outdoor
                || PrimaryType == XivItemType.painting)
            {
                return "";
            }

            var basePath = GetRootFolder();
            var modelName = "";
            if (PrimaryType == XivItemType.equipment || PrimaryType == XivItemType.accessory)
            {
                modelName = GetRacialModelName(race);
            }
            else
            {
                modelName = GetSimpleModelName();
            }
            return GetRootFolder() + "model/" + modelName;
        }

        public string GetMaterialPath(XivRace race = XivRace.All_Races, string suffix = "a", int materialVersion = 1, string fakeSlot = null)
        {
            if (PrimaryType == XivItemType.fish
                || PrimaryType == XivItemType.indoor
                || PrimaryType == XivItemType.outdoor
                || PrimaryType == XivItemType.painting)
            {
                throw new InvalidDataException("Material Path cannot be pre-calculated for SGB-using assets.");
            }

            const string MaterialFolderWithVariant = "{0}material/v{1}/";
            const string MaterialFolderWithoutVariant = "{0}material/";

            var basePath = GetRootFolder();

            if (UsesMaterialSets())
            {
                basePath = String.Format(MaterialFolderWithVariant, basePath, materialVersion.ToString("D4"));
            } else
            {
                basePath = String.Format(MaterialFolderWithoutVariant, basePath);
            }

            var materialName = "mt_" + GetBaseFileName();
            if (PrimaryType == XivItemType.equipment || PrimaryType == XivItemType.accessory)
            {
                materialName = "mt_" + GetRacialBaseName(race);
            }

            if(PrimaryType == XivItemType.human && SecondaryType == XivItemType.body && Slot != null)
            {
                // Fix for some hackiness in the human tree.  Body materials don't use a slot suffix.
                // But we keep the slot suffix set as [top] in that tree internally to retain tree sanity.
                materialName = materialName.Substring(0, materialName.Length - 4);
            } else if(fakeSlot != null && Slot != null)
            {
                // This is for stuff like human faces, where they use fake slot identifiers.
                materialName = materialName.Replace("_" + Slot, "_" + fakeSlot);
            }

            if(!string.IsNullOrWhiteSpace(suffix))
            {
                materialName += "_" + suffix;
            }
            materialName += ".mtrl";

            return basePath + materialName;
        }

        public async Task<string> GetNextAvailableMaterial(XivRace race = XivRace.All_Races, int materialVersion = 1, string fakeSlot = null, ModTransaction tx = null)
        {
            if(tx == null)
            {
                // Readonly TX if we don't have one.
                tx = ModTransaction.BeginTransaction();
            }
            if((int) race < 100)
            {
                race = XivRace.All_Races;
            }

            string openPath = null;
            foreach(var c in Constants.Alphabet)
            {
                var path = GetMaterialPath(race, c.ToString(), materialVersion, fakeSlot);
                if(!await tx.FileExists(path))
                {
                    openPath = path;
                    break;
                }
            }

            if(openPath == null)
            {
                // Double loop...
                foreach (var c in Constants.Alphabet)
                {
                    foreach (var c2 in Constants.Alphabet)
                    {
                        var path = GetMaterialPath(race, c.ToString() + c2.ToString(), materialVersion, fakeSlot);
                        if (!await tx.FileExists(path))
                        {
                            openPath = path;
                            break;
                        }
                    }
                }
            }

            if(openPath == null)
            {
                throw new Exception("All 26^26 Materials used...?");
            }

            return openPath;
        }

        /// <summary>
        /// Calculates and returns the SGD file name for this root.
        /// </summary>
        /// <returns></returns>
        public string GetSgbName()
        {
            if (PrimaryType != XivItemType.indoor && PrimaryType != XivItemType.outdoor && PrimaryType != XivItemType.fish)
            {
                throw new NotSupportedException("Cannot get SGB File for Non-Furniture item type.");
            }

            var slotFake = PrimaryType == XivItemType.indoor ? "fun" : "gar";

            if(PrimaryType == XivItemType.fish)
            {
                throw new NotImplementedException("Dynamic Sgb Resolution not implemented for fish.");
            }

            var assetFile = $"{slotFake}_b0_m{PrimaryId.ToString().PadLeft(4, '0')}.sgb";
            return assetFile;
        }
        
        public string GetRacialBaseName(XivRace race)
        {
            var pPrefix = XivItemTypes.GetSystemPrefix(XivItemType.human);
            var pId = race.GetRaceCode();
            var sPrefix = XivItemTypes.GetSystemPrefix(PrimaryType);
            var sId = PrimaryId.ToString().PadLeft(4, '0');

            string baseName;
            if (Slot != null)
            {
                baseName = String.Format(BaseFileFormatWithSlot, new string[] { pPrefix, pId, sPrefix, sId, Slot });
            }
            else
            {
                baseName = String.Format(BaseFileFormatNoSlot, new string[] { pPrefix, pId, sPrefix, sId });
            }
            return baseName;

        }

        private string GetSimpleModelName()
        {
            if (PrimaryType == XivItemType.equipment || PrimaryType == XivItemType.accessory)
            {
                throw new NotSupportedException("Cannot generate simple model name for this type. EQDP file must Be used.");
            }

            return String.Format(ModelNameFormat, new string[] { GetBaseFileName() });
        }
        private string GetRacialModelName(XivRace race)
        {
            if (SecondaryType != null)
            {
                throw new NotSupportedException("Cannot generate Racial Model name - Item Type does not use Racial Models.");
            }
            if(race == XivRace.All_Races)
            {
                throw new InvalidDataException("Racial model name cannot be retrieved without race id.");
            }

            var baseName = GetRacialBaseName(race);

            return String.Format(ModelNameFormat, new string[] { baseName });
        }

        public static bool operator ==(XivDependencyRootInfo obj1, XivDependencyRootInfo obj2)
        {

            if (object.ReferenceEquals(obj1, null) && object.ReferenceEquals(obj2, null)) return true;
            if (object.ReferenceEquals(obj1, null) || object.ReferenceEquals(obj2, null)) return false;

            return obj1.ToString() == obj2.ToString();
        }

        public static bool operator !=(XivDependencyRootInfo obj1, XivDependencyRootInfo obj2)
        {
            if (object.ReferenceEquals(obj1, null) && object.ReferenceEquals(obj2, null)) return false;
            if (object.ReferenceEquals(obj1, null) || object.ReferenceEquals(obj2, null)) return true;

            return obj1.ToString() != obj2.ToString();
        }

        public override bool Equals(object obj)
        {
            try
            {
                XivDependencyRootInfo other = (XivDependencyRootInfo)obj;
                return this == other;
            }
            catch
            {
                return false;
            }
        }
        public override int GetHashCode()
        {
            return this.ToString().GetHashCode();
        }

        public XivDependencyRoot ToFullRoot()
        {
            return XivDependencyGraph.CreateDependencyRoot(this);
        }

        public XivDependencyRootInfo Validate()
        {
            var newRoot = (XivDependencyRootInfo)this.Clone();
            if (PrimaryType == XivItemType.human && (SecondaryType == XivItemType.equipment || SecondaryType == XivItemType.accessory))
            {
                // These need to be inverted and blanked.
                newRoot.PrimaryType = SecondaryType.Value;
                newRoot.PrimaryId = SecondaryId.Value;
                newRoot.SecondaryId = null;
                newRoot.SecondaryType = null;
            }

            if (Slot == null)
            {
                // Safety checks.  Custom-name textures can often end up with set being resolvable
                // but slot non-resolvable.  Either way it's irrelevant, as 
                // they'll have their root resolved via modlist, if one exists for them.
                if (PrimaryType == XivItemType.equipment
                    || PrimaryType == XivItemType.accessory
                    || PrimaryType == XivItemType.demihuman)
                {
                    return new XivDependencyRootInfo();
                }
            }

            // Only these types can get away without a secondary type.
            if (SecondaryType == null)
            {
                if (PrimaryType != XivItemType.equipment && PrimaryType != XivItemType.accessory
                    && PrimaryType != XivItemType.indoor
                    && PrimaryType != XivItemType.outdoor
                    && PrimaryType != XivItemType.fish
                    && PrimaryType != XivItemType.painting)
                {
                    return new XivDependencyRootInfo();
                }
            }

            return newRoot;
        }
    }

    /// <summary>
    /// A class representing a top level dependency root.  This is in effect, a collection of
    /// five simple values [Type, Primary Id, Secondary Type, Secondary ID, Slot]
    /// All Entries have at least Primary Type and Id.
    /// From these five populated values, we can effectively generate the entire dependency tree downwards,
    /// and these five values can be generated from any child file via XivDependencyGraph::GetDependencyRoot(internalFilePath)
    /// 
    /// This class wraps the child Info class with some additional sanity checks, via creation through the cache/dependency graph.
    /// A successful creation through those functions should always guarantee a valid DependencyRoot object, which can
    /// fully resolve all of its constituent parts.
    /// 
    /// Likewise, this class can be turned into an IItem with a generic name via the .ToItem() function.
    /// </summary>
    public class XivDependencyRoot
    {
        /// <summary>
        /// The actual relevant datapoints.
        /// </summary>
        public readonly XivDependencyRootInfo Info;

        // sPrefix => sId (or Primary if Secondary not available)
        private static readonly string ImcFileFormat = "{0}{1}.imc";

        public XivDependencyRoot(XivItemType type, int pid, XivItemType? secondaryType = null, int? sid = null, string slot = null) : this(new XivDependencyRootInfo()
        {
            PrimaryType = type,
            Slot = slot,
            PrimaryId = pid,
            SecondaryType = secondaryType,
            SecondaryId = sid
        })
        {
        }
        public XivDependencyRoot(XivDependencyRootInfo info)
        {
            Info = info;


            // Exception handling time!
            // These item subtypes at root level only have one slot
            // it's only at the Material level they're allowed to have other "slots", 
            // and those are simply defined by the name references in the MDL files.

            // Essentially, they're cross-referenced materials that don't actually have a parent tree, so they
            // should belong to the base tree for those item types.
            if (Info.PrimaryType == XivItemType.human)
            {
                if (Info.SecondaryType == XivItemType.face)
                {
                    Info.Slot = "fac";
                }
                else if (Info.SecondaryType == XivItemType.ear)
                {
                    Info.Slot = "zer";
                }
                else if (Info.SecondaryType == XivItemType.tail)
                {
                    Info.Slot = "til";
                }
                else if (Info.SecondaryType == XivItemType.hair)
                {
                    Info.Slot = "hir";
                }
                else if (Info.Slot == null)
                {
                    // Kind of a hack, but works to keep the tree together.
                    // Skin materials/textures don't have a slot associated, because they're used by all slots, so
                    // initial crawls up the tree are janky.
                    Info.Slot = "top";
                }
            }
            else if (Info.PrimaryType == XivItemType.indoor || Info.PrimaryType == XivItemType.outdoor)
            {
                // No slots here!
                Info.Slot = null;
            }
        }

        public static bool operator ==(XivDependencyRoot obj1, XivDependencyRoot obj2)
        {

            if (object.ReferenceEquals(obj1, null) && object.ReferenceEquals(obj2, null)) return true;
            if (object.ReferenceEquals(obj1, null) || object.ReferenceEquals(obj2, null)) return false;

            return obj1.ToString() == obj2.ToString();
        }

        public static bool operator !=(XivDependencyRoot obj1, XivDependencyRoot obj2)
        {
            if (object.ReferenceEquals(obj1, null) && object.ReferenceEquals(obj2, null)) return false;
            if (object.ReferenceEquals(obj1, null) || object.ReferenceEquals(obj2, null)) return true;

            return obj1.ToString() != obj2.ToString();
        }

        public override bool Equals(object obj)
        {
            try
            {
                XivDependencyRoot other = (XivDependencyRoot)obj;
                return this == other;
            }
            catch
            {
                return false;
            }
        }
        public override string ToString()
        {
            return Info.ToString();
        }
        public override int GetHashCode()
        {
            return Info.ToString().GetHashCode();
        }

        /// <summary>
        /// Retrieves ALL files used by this root.
        /// </summary>
        /// <param name="index"></param>
        /// <param name="modlist"></param>
        /// <returns></returns>
        public async Task<SortedSet<string>> GetAllFiles(ModTransaction tx = null, bool includeOrphanMaterials = true)
        {

            var df = IOUtil.GetDataFileFromPath(Info.GetRootFile());

            var files = new HashSet<string>();

            if (tx == null)
            {
                tx = ModTransaction.BeginTransaction();
            }

            ItemMetadata originalMetadata = await ItemMetadata.GetMetadata(this, false, tx);

            var originalModelPaths = await GetModelFiles(tx);
            var originalMaterialPaths = await GetMaterialFiles(-1, tx, includeOrphanMaterials);
            var originalTexturePaths = await GetTextureFiles(-1, tx);

            var originalVfxPaths = new HashSet<string>();
            if (Imc.UsesImc(this))
            {
                var avfxSets = originalMetadata.ImcEntries.Select(x => x.Vfx).Distinct();
                foreach (var avfx in avfxSets)
                {
                    var avfxStuff = await ATex.GetVfxPath(Info, avfx);
                    if (String.IsNullOrEmpty(avfxStuff.Folder) || String.IsNullOrEmpty(avfxStuff.File)) continue;

                    var path = avfxStuff.Folder + "/" + avfxStuff.File;
                    if (await tx.FileExists(path))
                    {
                        originalVfxPaths.Add(path);
                        var paths = await ATex.GetAtexPaths(path, false, tx);
                        foreach (var p in paths)
                        {
                            originalVfxPaths.Add(p);
                        }
                    }
                }
            }

            var af = originalModelPaths.Select(x => x).Union(
                originalMaterialPaths.Select(x => x)).Union(
                originalTexturePaths.Select(x => x)).Union(
                originalVfxPaths.Select(x => x));

            var allFiles = new SortedSet<string>();
            foreach (var f in af)
            {
                allFiles.Add(f);
            }

            allFiles.Add(Info.GetRootFile());

            return allFiles;
        }

        /// <summary>
        /// Gets all the model files in this dependency chain.
        /// </summary>
        /// <returns></returns>
        public async Task<List<string>> GetModelFiles(ModTransaction tx = null)
        {
            // Some chains have no meta entries, and jump straight to models.
            // Try to resolve Meta files first.
            if (Info.PrimaryType == XivItemType.equipment || Info.PrimaryType == XivItemType.accessory)
            {
                var _eqp = new Eqp(XivCache.GameInfo.GameDirectory);

                List<XivRace> races = null;
                if (tx != null)
                {
                    var metadata = await ItemMetadata.GetMetadata(this, false, tx);
                    races = metadata.EqdpEntries.Where(x => x.Value.bit1).Select(x => x.Key).ToList();
                }
                else
                {
                    races = await _eqp.GetAvailableRacialModels(Info.PrimaryId, Info.Slot, false, true, tx);
                }

                var models = new List<string>();
                foreach (var race in races)
                {
                    models.Add(Info.GetModelPath(race));
                }
                return models;
            }
            else if (Info.PrimaryType == XivItemType.indoor || Info.PrimaryType == XivItemType.outdoor || Info.PrimaryType == XivItemType.fish)
            {
                var _housing = new Housing(XivCache.GameInfo.GameDirectory, XivCache.GameInfo.GameLanguage);
                var housingAssets = await _housing.GetFurnitureModelParts(Info.PrimaryId, Info.SecondaryId, Info.PrimaryType, tx);
                return housingAssets.Select(x => x.Value).ToList();
            }
            else
            {


                // The rest of the types just have a single, calculateable model path.
                var modelPath = Info.GetModelPath();


                if (Info.PrimaryType == XivItemType.human && Info.SecondaryType != XivItemType.hair && Info.SecondaryId / 100 >= 1)
                {
                    // For human types, if their model is missing, the version 00xx is used instead.
                    if (tx == null)
                    {
                        // Readonly TX if we don't have one.
                        tx = ModTransaction.BeginTransaction();
                    }

                    if (!(await tx.FileExists(modelPath)))
                    {
                        var replacementNumber = (Info.SecondaryId % 100);
                        var alteredRoot = new XivDependencyRoot(Info.PrimaryType, Info.PrimaryId, Info.SecondaryType, replacementNumber, Info.Slot);

                        return await alteredRoot.GetModelFiles(tx);
                    }
                }

                if (!await tx.FileExists(modelPath))
                {
                    return new List<string>();
                }

                return new List<string>() { modelPath };
            }

        }

        private static readonly Regex _materialSetRegex = new Regex("v[0-9]{4}");

        /// <summary>
        /// Gets all the unique material files in this depency chain.
        /// Subsets of this data may be accessed with XivDependencyGraph::GetChildFiles(internalFilePath).
        /// </summary>
        /// <returns></returns>
        public async Task<List<string>> GetMaterialFiles(int materialVariant = -1, ModTransaction tx = null, bool includeOrphans = true)
        {
            var df = Info.PrimaryType.GetDataFile();
            IndexFile index;
            ModList modlist;
            bool useCache = false;
            if (tx == null)
            {
                // Use a read only transaction if we don't have an open one.
                // If we're not transacting that also means we can just use whatever's in the main state cache.
                tx = ModTransaction.BeginTransaction();
                useCache = true;
            }

            index = await tx.GetIndexFile(df);
            modlist = await tx.GetModList();

            var materials = new HashSet<string>();
            if (Info.PrimaryType == XivItemType.human && Info.SecondaryType == XivItemType.body)
            {
                // Bleargh.  So here's the exception of exception class.  Because the "models" in human body are 
                // are so sparse and all over the place, relying on them is impossible.  Thankfully, body types only ever
                // have one vanilla material.
                var primary = Info.PrimaryId.ToString().PadLeft(4, '0');
                var body = Info.SecondaryId.ToString().PadLeft(4, '0');
                var path = $"chara/human/c{primary}/obj/body/b{body}/material/v0001/mt_c{primary}b{body}_a.mtrl";

                // Just validate it exists and call it a day.

                var exists = index.FileExists(path);
                if (exists)
                {
                    materials.Add(path);
                }

                // XXX: I noticed female hrothgar also have patterns so I'm gonna put them here too
                if (Info.PrimaryId == XivRace.Hrothgar_Male.GetRaceCodeInt()
#if DAWNTRAIL
                    || Info.PrimaryId == XivRace.Hrothgar_Female.GetRaceCodeInt()
#endif
                    )
                {
                    // JK, Hrothgar actually have 5 material sets (that's how their fur pattern stuff is set)
                    for (int i = 2; i <= 5; i++)
                    {
                        var mSet = i.ToString().PadLeft(4, '0');
                        path = $"chara/human/c{primary}/obj/body/b{body}/material/v{mSet}/mt_c{primary}b{body}_a.mtrl";
                        materials.Add(path);
                    }
                }

                materialVariant = -1;
            }
            else if (Info.PrimaryType == XivItemType.painting)
            {

                var pId = Info.PrimaryId.ToString().PadLeft(4, '0');
                var mtrl = Info.GetRootFolder() + "material/pic_ta_2" + pId + "a.mtrl";
                // TODO : Should we check for existence here or not?
                materials.Add(mtrl);
            }
            else
            {
                var models = await GetModelFiles(tx);
                if (models != null && models.Count > 0)
                {
                    var dataFile = IOUtil.GetDataFileFromPath(models[0]);



                    foreach (var model in models)
                    {
                        var modelMats = await GetVariantShiftedMaterials(model, materialVariant, tx);
                        materials.UnionWith(modelMats);
                    }
                }
            }


            if (includeOrphans)
            {
                var orphans = await GetModdedMaterials(materialVariant, tx);
                materials.UnionWith(orphans);
            }


            return materials.ToList();
        }

        public async Task<HashSet<string>> GetVariantShiftedMaterials(string modelPath, int materialVariant = -1, ModTransaction tx = null)
        {
            if (tx == null)
            {
                // Readonly TX if we don't have one.
                tx = ModTransaction.BeginTransaction();
            }

            List<string> mdlMats = null;
            mdlMats = await XivCache.GetChildFiles(modelPath, tx);
            return GetVariantShiftedMaterials(mdlMats, materialVariant);
        }
        public HashSet<string> GetVariantShiftedMaterials(List<string> mdlMats, int materialVariant = -1)
        {
            HashSet<string> materials = new HashSet<string>();

            if (mdlMats != null)
            {
                if (materialVariant <= 0)
                {
                    foreach (var mat in mdlMats)
                    {
                        var m = mat;

                        // Human types have their material ID automatically changed over.
                        if (Info.PrimaryType == XivItemType.human && (Info.SecondaryType == XivItemType.body || Info.SecondaryType == XivItemType.hair))
                        {
                            var secondaryTypePrefix = XivItemTypes.GetSystemPrefix((XivItemType)Info.SecondaryType);
                            var secondaryRex = new Regex("(" + secondaryTypePrefix + "[0-9]{4})");
                            m = secondaryRex.Replace(m, secondaryTypePrefix + Info.SecondaryId.ToString().PadLeft(4, '0'));
                        }
                        materials.Add(m);
                    }
                }
                else
                {
                    var replacement = "v" + materialVariant.ToString().PadLeft(4, '0');
                    foreach (var mat in mdlMats)
                    {
                        // Replace any material set references with the new one.
                        // The hash set will scrub us down to just a single copy.
                        // This is faster than re-scanning the MDL file.
                        // And a little more thorough than simply skipping over non-matching refs.
                        // Since some materials may not have variant references.
                        var m = _materialSetRegex.Replace(mat, replacement);

                        // Human types have their material ID automatically fixed to match.
                        if (Info.PrimaryType == XivItemType.human && Info.SecondaryType != XivItemType.hair)
                        {
                            var secondaryTypePrefix = XivItemTypes.GetSystemPrefix((XivItemType)Info.SecondaryType);
                            var secondaryRex = new Regex("(" + secondaryTypePrefix + "[0-9]{4})");
                            m = secondaryRex.Replace(m, secondaryTypePrefix + Info.SecondaryId.ToString().PadLeft(4, '0'));
                        }
                        materials.Add(m);
                    }
                }
            }
            return materials;
        }

        public async Task<HashSet<string>> GetOrphanedFiles(ModTransaction tx = null)
        {
            if (tx == null)
            {
                // Readonly TX if we don't have one.
                tx = ModTransaction.BeginTransaction();
            }

            var keptFiles = await GetAllFiles(tx, false);

            var ml = await tx.GetModList();


            var orphans = new HashSet<string>();
            var mods = ml.GetMods();
            foreach (var mod in mods)
            {
                var modRoot = await XivCache.GetFirstRoot(mod.FilePath);
                if (modRoot == this && !keptFiles.Contains(mod.FilePath))
                {
                    orphans.Add(mod.FilePath);
                }
            }
            return orphans;
        }

        public async Task<HashSet<string>> GetModdedMaterials(int materialVariant = -1, ModTransaction tx = null)
        {
            if (tx == null)
            {
                // Readonly TX if we don't have one.
                tx = ModTransaction.BeginTransaction();
            }
            var materials = new HashSet<string>();

            // Add orphaned modded materials into the root.
            var rootFolder = Info.GetRootFolder();
            var variantRep = "v" + materialVariant.ToString().PadLeft(4, '0');
            var mods = (await tx.GetModList()).GetMods(x => x.FilePath.StartsWith(rootFolder) && x.FilePath.EndsWith(".mtrl"));
            foreach (var mod in mods)
            {
                var state = await mod.GetState(tx);
                if (state != Mods.Enums.EModState.Enabled) continue;
                if (Info.Slot == null || mod.FilePath.Contains(Info.Slot) || Info.PrimaryType == XivItemType.human)
                {
                    var material = mod.FilePath;
                    if (materialVariant >= 0)
                    {
                        materials.Add(_materialSetRegex.Replace(material, variantRep));
                    }
                    else
                    {
                        materials.Add(material);
                    }
                }
            }
            return materials;
        }

        /// <summary>
        /// Gets all of the unique texture files in this depency chain.
        /// Subsets of this data may be accessed with XivDependencyGraph::GetChildFiles(internalFilePath).
        /// </summary>
        /// <returns></returns>
        public async Task<List<string>> GetTextureFiles(int materialVariant = -1, ModTransaction tx = null)
        {
            var materials = await GetMaterialFiles(materialVariant, tx);
            var textures = new HashSet<string>();
            if (materials != null && materials.Count > 0)
            {
                foreach (var mat in materials)
                {
                    List<string> mtrlTexs = new List<string>();
                    if (tx == null)
                    {
                        mtrlTexs = await XivCache.GetChildFiles(mat, tx);
                    }
                    else
                    {
                        var dataFile = IOUtil.GetDataFileFromPath(mat);
                        var index = await tx.GetIndexFile(dataFile);

                        if (index.Get8xDataOffset(mat) != 0)
                        {
                            mtrlTexs = await Mtrl.GetTexturePathsFromMtrlPath(mat, false, false, tx);
                        }
                    }

                    foreach (var tex in mtrlTexs)
                    {
                        textures.Add(tex);
                    }
                }
            }
            return textures.ToList();
        }


        public string GetRawImcFilePath()
        {
            var imcPath = "";
            if (Info.PrimaryType == XivItemType.indoor || Info.PrimaryType == XivItemType.outdoor)
            {
                // These types can never have IMC entries.
                return null;
            }


            if (Info.SecondaryType == null)
            {
                var iPrefix = XivItemTypes.GetSystemPrefix(Info.PrimaryType);
                var iId = Info.PrimaryId.ToString().PadLeft(4, '0');
                imcPath = Info.GetRootFolder() + String.Format(ImcFileFormat, new string[] { iPrefix, iId });
            }
            else
            {
                var iPrefix = XivItemTypes.GetSystemPrefix((XivItemType)Info.SecondaryType);
                var iId = Info.SecondaryId.ToString().PadLeft(4, '0');
                imcPath = Info.GetRootFolder() + String.Format(ImcFileFormat, new string[] { iPrefix, iId });
            }
            return imcPath;

        }

        /// <summary>
        /// Gets all IMC Entries associated with this root node.
        /// </summary>
        /// <returns></returns>
        public async Task<List<string>> GetImcEntryPaths(ModTransaction tx = null)
        {
            if (tx == null)
            {
                // Readonly TX if we don't have one.
                tx = ModTransaction.BeginTransaction();
            }

            // We need to locate and open the IMC file, and then check how many
            // actual sets are in it, and calculate the pointers to our associated
            // Set + Slot entries.
            // Then return them in the format of <ImcPath>::<Offset>
            var imcEntries = new List<string>();

            var imcPath = GetRawImcFilePath();

            if (String.IsNullOrEmpty(imcPath))
            {
                return imcEntries;
            }


            var _gameDirectory = XivCache.GameInfo.GameDirectory;

            if (tx == null)
            {
                // Readonly Tx if we don't have one.
                tx = ModTransaction.BeginTransaction();
            }

            if (!await tx.FileExists(imcPath))
            {
                // Some chains don't have IMC files.
                return imcEntries;
            }

            var imcByteData = await Dat.ReadFile(imcPath, false, tx);

            var subsetCount = 0;
            ImcType identifier = ImcType.Unknown;
            using (var br = new BinaryReader(new MemoryStream(imcByteData)))
            {
                subsetCount = br.ReadInt16();
                identifier = (ImcType)br.ReadInt16();
            };

            if (identifier == ImcType.Unknown)
            {
                return imcEntries;
            }

            const int startingOffset = 4;
            const int subEntrySize = 6;
            var entrySize = identifier == ImcType.NonSet ? subEntrySize : subEntrySize * 5;
            var subOffset = 0;
            if (Info.Slot != null && Imc.SlotOffsetDictionary.ContainsKey(Info.Slot))
            {
                subOffset = Imc.SlotOffsetDictionary[Info.Slot] * subEntrySize;
            }

            var offset = startingOffset + subOffset;

            for (int i = 0; i <= subsetCount; i++)
            {
                offset = startingOffset + (i * entrySize) + subOffset;
                imcEntries.Add(imcPath + Constants.BinaryOffsetMarker + (offset * 8).ToString());
            }

            return imcEntries;
        }




        /// <summary>
        /// Returns a raw item entry for this root.  Uses generic name, and does not contain an EXD row reference.
        /// </summary>
        /// <param name="DefaultImcSubset"></param>
        /// <returns></returns>
        public IItemModel ToRawItem(int defaultImcSubset = 0)
        {
            // If we couldn't find an item in the DB, or we failed to properly generate the item entry, just generate a default one.
            switch (Info.PrimaryType)
            {
                case XivItemType.equipment:
                case XivItemType.accessory:
                case XivItemType.weapon:
                    return XivGear.FromDependencyRoot(this, defaultImcSubset);
                case XivItemType.demihuman:
                case XivItemType.monster:
                    return XivMount.FromDependencyRoot(this, defaultImcSubset);
                case XivItemType.indoor:
                case XivItemType.outdoor:
                case XivItemType.fish:
                case XivItemType.painting:
                    return XivFurniture.FromDependencyRoot(this);
                case XivItemType.human:
                    return XivCharacter.FromDependencyRoot(this);
            }
            return XivGenericItemModel.FromDependencyRoot(this, defaultImcSubset);
        }
        /// <summary>
        /// Creates and returns an IIteModel instance based on this root's information.
        /// This will match the IItem entry available in the main item lists, if an item exists for this root.
        /// Otherwise, it will be a generically named one.
        /// </summary>
        /// <returns></returns>
        public IItemModel GetFirstItem(int defaultImcSubset = -1)
        {
            using (var db = new SQLiteConnection(XivCache.CacheConnectionString))
            {
                db.Open();
                var rootString = Info.ToString();

                if (Info.PrimaryType == XivItemType.equipment || Info.PrimaryType == XivItemType.accessory || Info.PrimaryType == XivItemType.weapon)
                {
                    var query = "select * from items where root = $root order by name asc;";
                    using (var cmd = new SQLiteCommand(query, db))
                    {
                        cmd.Parameters.AddWithValue("root", rootString);

                        using (var reader = new CacheReader(cmd.ExecuteReader()))
                        {
                            while (reader.NextRow())
                            {
                                // Found one.
                                var gear = XivCache.MakeGear(reader);
                                if (defaultImcSubset < 0 || gear.ModelInfo.ImcSubsetID == defaultImcSubset)
                                {
                                    return gear;
                                }
                            }
                        }
                    }
                }
                else if (Info.PrimaryType == XivItemType.demihuman || Info.PrimaryType == XivItemType.monster)
                {
                    var query = "select * from monsters where root = $root order by name asc;";
                    using (var cmd = new SQLiteCommand(query, db))
                    {
                        cmd.Parameters.AddWithValue("root", rootString);

                        using (var reader = new CacheReader(cmd.ExecuteReader()))
                        {
                            if (reader.NextRow())
                            {
                                // Found one.
                                return XivCache.MakeMonster(reader);
                            }
                        }
                    }

                }
                else if (Info.PrimaryType == XivItemType.indoor || Info.PrimaryType == XivItemType.outdoor || Info.PrimaryType == XivItemType.fish || Info.PrimaryType == XivItemType.painting)
                {
                    var query = "select * from furniture where root = $root order by name asc;";
                    using (var cmd = new SQLiteCommand(query, db))
                    {
                        cmd.Parameters.AddWithValue("root", rootString);

                        using (var reader = new CacheReader(cmd.ExecuteReader()))
                        {
                            if (reader.NextRow())
                            {
                                // Found one.
                                return XivCache.MakeFurniture(reader);
                            }
                        }
                    }
                }
            }
            defaultImcSubset = 0;
            return ToRawItem(defaultImcSubset);

        }

        /// <summary>
        /// Retrieves all items in this root, including NPC items.
        /// If an IMC subset is supplied, the list is filtered to that subset before being returned.
        /// </summary>
        /// <param name="imcSubset"></param>
        /// <returns></returns>
        public async Task<List<IItemModel>> GetAllItems(int imcSubset = -1, ModTransaction tx = null)
        {

            var items = new List<IItemModel>();
            using (var db = new SQLiteConnection(XivCache.CacheConnectionString))
            {
                db.Open();
                var rootString = Info.ToString();

                if (Info.PrimaryType == XivItemType.equipment || Info.PrimaryType == XivItemType.accessory || Info.PrimaryType == XivItemType.weapon)
                {
                    var query = "select * from items where root = $root order by name asc;";
                    using (var cmd = new SQLiteCommand(query, db))
                    {
                        cmd.Parameters.AddWithValue("root", rootString);

                        using (var reader = new CacheReader(cmd.ExecuteReader()))
                        {
                            while (reader.NextRow())
                            {
                                // Found one.
                                items.Add(XivCache.MakeGear(reader));
                            }
                        }
                    }
                }
                else if (Info.PrimaryType == XivItemType.demihuman || Info.PrimaryType == XivItemType.monster)
                {
                    var query = "select * from monsters where root = $root order by name asc;";
                    using (var cmd = new SQLiteCommand(query, db))
                    {
                        cmd.Parameters.AddWithValue("root", rootString);

                        using (var reader = new CacheReader(cmd.ExecuteReader()))
                        {
                            while (reader.NextRow())
                            {
                                // Found one.
                                items.Add(XivCache.MakeMonster(reader));
                            }
                        }
                    }
                }
                else if (Info.PrimaryType == XivItemType.indoor || Info.PrimaryType == XivItemType.outdoor || Info.PrimaryType == XivItemType.fish || Info.PrimaryType == XivItemType.painting)
                {
                    var query = "select * from furniture where root = $root order by name asc;";
                    using (var cmd = new SQLiteCommand(query, db))
                    {
                        cmd.Parameters.AddWithValue("root", rootString);

                        using (var reader = new CacheReader(cmd.ExecuteReader()))
                        {
                            while (reader.NextRow())
                            {
                                // Found one.
                                items.Add(XivCache.MakeFurniture(reader));
                            }
                        }
                    }
                }
            }

            /// For these types we also want to read their IMC file to fill in any missing NPC only versions.
            if (Imc.UsesImc(this))
            {
                var imcPaths = await GetImcEntryPaths(tx);
                var imcEntries = await Imc.GetEntries(imcPaths, false, tx);

                // Need to verify all of our IMC sets are properly represented in the item list.
                for (int i = 0; i < imcEntries.Count; i++)
                {
                    // Already in it.  All set.
                    if (items.Any(x => x.ModelInfo.ImcSubsetID == i)) continue;

                    // Need to create a new item for it.
                    var npcItem = ToRawItem(i);
                    items.Add(npcItem);
                }
            }

            if (imcSubset >= 0)
            {
                items = items.Where(x => x.ModelInfo.ImcSubsetID == imcSubset).ToList();
            }

            if (items.Count == 0)
            {
                var val = imcSubset >= 0 ? imcSubset : 0;
                // May as well make a raw item.
                items.Add(ToRawItem(val));
            }

            items = items.OrderBy(x => x.Name, new ItemNameComparer()).ToList();

            return items;
        }
    }

}
